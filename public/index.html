<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>Couples Breath</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; font-family: -apple-system, system-ui, Arial, sans-serif;
      display: grid; place-items: center; min-height: 100dvh;
      background: #0b0b0c; color: #eaeaea;
    }
    .card {
      width: min(680px, 92vw); padding: 20px 18px; border-radius: 18px;
      background: #121216; box-shadow: 0 6px 24px rgba(0,0,0,0.35);
      border: 1px solid #23232a;
    }
    h1 { margin: 0 0 6px; font-size: 22px; letter-spacing: 0.3px; }
    .sub { color: #a4a4ad; font-size: 13px; margin-bottom: 14px; }
    .row { display: flex; gap: 14px; align-items: center; flex-wrap: wrap; margin: 10px 0 16px; }
    button {
      appearance: none; border: 0; border-radius: 12px; padding: 12px 16px;
      font-weight: 600; background: #3b82f6; color: white; font-size: 16px;
    }
    button.secondary { background: #2d2d34; color: #ddd; }
    .status {
      display: grid; grid-template-columns: 110px 1fr; gap: 10px;
      font-size: 14px; line-height: 1.8;
    }
    .kv label { color: #8d8d97; display: inline-block; width: 110px; }
    .meter {
      height: 10px; background: #1c1c22; border-radius: 999px; overflow: hidden; border: 1px solid #2a2a33;
    }
    .meter > i { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, #f59e0b, #ef4444); }
    .banner {
      display: none;
      margin-top: 14px; padding: 14px; border-radius: 14px;
      background: #172554; border: 1px solid #1d4396; color: #cfe1ff; font-size: 15px;
    }
    .banner.show { display: block; }
    .tiny { font-size: 12px; color: #8b8b96; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Couples Breath</h1>
    <div class="sub">softly say something, then tap Start — I’ll listen for spikes and cue a pause</div>

    <div class="row">
      <button id="btn">Start</button>
      <button id="clear" class="secondary">Clear</button>
      <div id="mode" class="tiny">mode: …</div>
    </div>

    <div class="status">
      <div class="kv"><label>Status</label><span id="status">idle</span></div>
      <div class="kv"><label>Hyper level</label><span id="level">—</span></div>
      <div class="kv"><label>Meter</label>
        <div class="meter"><i id="fill"></i></div>
      </div>
    </div>

    <div id="banner" class="banner">Pause to breathe — in 4, out 6. When you’re ready, continue.</div>

    <div id="log" class="tiny" style="margin-top:12px; white-space: pre-wrap;"></div>
  </div>

<script>
(() => {
  const btn    = document.getElementById('btn');
  const clear  = document.getElementById('clear');
  const statusEl = document.getElementById('status');
  const levelEl  = document.getElementById('level');
  const fill   = document.getElementById('fill');
  const banner = document.getElementById('banner');
  const logEl  = document.getElementById('log');
  const modeEl = document.getElementById('mode');

  let ws = null;
  let mediaStream = null;
  let audioCtx = null;
  let processor = null;
  let source = null;

  // Phone-friendly WAV encoder (mono 16kHz 16-bit)
  function downsampleBuffer(buffer, inputSampleRate, outputSampleRate) {
    if (outputSampleRate === inputSampleRate) return buffer;
    const ratio = inputSampleRate / outputSampleRate;
    const newLength = Math.round(buffer.length / ratio);
    const result = new Float32Array(newLength);
    let offsetResult = 0;
    let offsetBuffer = 0;
    while (offsetResult < result.length) {
      const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
      // average to reduce aliasing
      let accum = 0, count = 0;
      for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
        accum += buffer[i]; count++;
      }
      result[offsetResult] = accum / (count || 1);
      offsetResult++;
      offsetBuffer = nextOffsetBuffer;
    }
    return result;
  }

  function floatTo16BitPCM(float32) {
    const out = new DataView(new ArrayBuffer(float32.length * 2));
    let offset = 0;
    for (let i = 0; i < float32.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, float32[i]));
      out.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
    return out;
  }

  function writeWavHeader(view, sampleRate, numSamples) {
    const blockAlign = 2; // mono 16-bit
    const byteRate = sampleRate * blockAlign;
    const dataSize = numSamples * blockAlign;

    // ChunkID 'RIFF'
    view.setUint32(0, 0x46464952, false);
    // ChunkSize 36 + Subchunk2Size
    view.setUint32(4, 36 + dataSize, true);
    // Format 'WAVE'
    view.setUint32(8, 0x45564157, false);

    // Subchunk1ID 'fmt '
    view.setUint32(12, 0x20746d66, false);
    // Subchunk1Size 16
    view.setUint32(16, 16, true);
    // AudioFormat (1 = PCM)
    view.setUint16(20, 1, true);
    // NumChannels
    view.setUint16(22, 1, true);
    // SampleRate
    view.setUint32(24, sampleRate, true);
    // ByteRate
    view.setUint32(28, byteRate, true);
    // BlockAlign
    view.setUint16(32, blockAlign, true);
    // BitsPerSample
    view.setUint16(34, 16, true);

    // Subchunk2ID 'data'
    view.setUint32(36, 0x61746164, false);
    // Subchunk2Size
    view.setUint32(40, dataSize, true);
  }

  function encodeWav(int16View, sampleRate) {
    const buffer = new ArrayBuffer(44 + int16View.byteLength);
    const view = new DataView(buffer);
    writeWavHeader(view, sampleRate, int16View.byteLength / 2);
    // payload
    const payload = new Uint8Array(buffer, 44);
    const src = new Uint8Array(int16View.buffer);
    payload.set(src);
    return new Blob([view], { type: 'audio/wav' });
  }

  function toBase64(arrayBuffer) {
    let binary = '';
    const bytes = new Uint8Array(arrayBuffer);
    const chunk = 0x8000;
    for (let i = 0; i < bytes.length; i += chunk) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
    }
    return btoa(binary);
  }

  function log(line) {
    const t = new Date().toLocaleTimeString();
    logEl.textContent = `[${t}] ${line}\n` + logEl.textContent;
  }

  function setLevel(v) {
    if (typeof v !== 'number' || isNaN(v)) { levelEl.textContent = '—'; fill.style.width = '0%'; return; }
    levelEl.textContent = v.toFixed(2);
    fill.style.width = Math.min(100, Math.max(0, v * 100)).toFixed(0) + '%';
  }

  function vibrate(ms=100) { if (navigator.vibrate) try { navigator.vibrate(ms); } catch {} }

  function connectWS() {
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${proto}://${location.host}/client`;
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      statusEl.textContent = 'connected';
      log('ws open');
    };
    ws.onclose = (e) => {
      statusEl.textContent = 'closed';
      log(`ws close ${e.code || ''}`);
    };
    ws.onerror = (e) => {
      log('ws error');
    };
    ws.onmessage = (ev) => {
      let msg; try { msg = JSON.parse(ev.data); } catch { return; }
      if (msg.type === 'hello') {
        modeEl.textContent = `mode: ${msg.mode}`;
      } else if (msg.type === 'hume' && msg.status) {
        log(`hume: ${msg.status}`);
      } else if (msg.type === 'risk') {
        setLevel(msg.hyper);
      } else if (msg.type === 'trigger' && msg.kind === 'hyper') {
        banner.classList.add('show');
        vibrate(150);
        log(`TRIGGER hyper ${msg.score?.toFixed?.(2)}`);
      }
    };
  }

  async function start() {
    banner.classList.remove('show');
    setLevel(null);
    statusEl.textContent = 'starting…';

    if (!ws || ws.readyState !== WebSocket.OPEN) connectWS();

    // iOS Safari needs this directly from a user gesture
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 }); // typical input rate
    source = audioCtx.createMediaStreamSource(mediaStream);
    processor = audioCtx.createScriptProcessor(4096, 1, 1);

    const TARGET_RATE = 16000; // 16 kHz mono
    let chunkAcc = [];  // Float32 chunks
    let accLen = 0;
    const CHUNK_MS = 1000; // send ~1s WAV chunks

    let lastSend = performance.now();

    processor.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      chunkAcc.push(input.slice(0));
      accLen += input.length;

      const now = performance.now();
      if (now - lastSend >= CHUNK_MS) {
        // concat
        const big = new Float32Array(accLen);
        let off = 0;
        for (const b of chunkAcc) { big.set(b, off); off += b.length; }
        chunkAcc = []; accLen = 0;
        lastSend = now;

        // downsample → int16 → wav → base64
        const ds = downsampleBuffer(big, audioCtx.sampleRate, TARGET_RATE);
        const int16 = floatTo16BitPCM(ds);
        const wavBlob = encodeWav(int16, TARGET_RATE);

        wavBlob.arrayBuffer().then(buf => {
          const b64 = toBase64(buf);
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'audio', data_b64: b64 }));
            log(`sent wav bytes ${b64.length}`);
          }
        });
      }
    };

    source.connect(processor);
    processor.connect(audioCtx.destination);
    statusEl.textContent = 'recording';
    btn.textContent = 'Stop';
  }

  function stop() {
    banner.classList.remove('show');
    setLevel(null);
    statusEl.textContent = 'idle';
    btn.textContent = 'Start';

    if (processor) { try { processor.disconnect(); } catch {} processor.onaudioprocess = null; processor = null; }
    if (source)    { try { source.disconnect(); } catch {} source = null; }
    if (audioCtx)  { try { audioCtx.close(); } catch {} audioCtx = null; }
    if (mediaStream) {
      mediaStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
      mediaStream = null;
    }
  }

  btn.addEventListener('click', async () => {
    if (btn.textContent === 'Start') {
      try { await start(); } catch (e) { statusEl.textContent = 'mic error'; log('mic error: ' + e.message); }
    } else {
      stop();
    }
  });

  clear.addEventListener('click', () => {
    banner.classList.remove('show');
    setLevel(null);
    logEl.textContent = '';
  });

  // connect right away so “mode: …” appears; mic starts only after tapping Start
  connectWS();
})();
</script>
</body>
</html>
