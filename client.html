<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Couples Breath</title>
  <style>
    :root{
      --bg:#0a0b0e;           /* app background */
      --panel:#12151b;        /* card */
      --text:#e9eef4;         /* primary text */
      --muted:#9fb1c5;        /* secondary */
      --accent:#27c199;       /* start (green) */
      --danger:#e53935;       /* stop & overlay box (red) */
      --border:#1f2732;
      --shadow:0 8px 30px rgba(0,0,0,.35);
      --radius:16px;
      --pad:16px;
      --tapScale:.98;         /* tap feedback */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .page{
      min-height:100%;
      padding: max(env(safe-area-inset-top, 0px), 12px)
               max(env(safe-area-inset-right, 0px), 16px)
               max(env(safe-area-inset-bottom, 0px), 20px)
               max(env(safe-area-inset-left, 0px), 16px);
      display:flex;
      justify-content:center;
    }
    .wrap{
      width:100%;
      max-width:720px;  /* prevents right edge cutoff on phones */
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    header.card{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding:14px 16px; background:var(--panel);
      border:1px solid var(--border); border-radius:var(--radius);
      box-shadow:var(--shadow);
    }
    .brand{
      font-weight:700; letter-spacing:.3px;
    }
    .pill{
      font-size:12px; color:var(--muted);
      background:#0f1217; border:1px solid var(--border);
      padding:6px 10px; border-radius:999px;
    }

    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:16px;
    }

    .row{ display:flex; gap:12px; align-items:center; }
    .row.wrap{ flex-wrap:wrap; }

    .btn{
      appearance:none; border:1px solid var(--border);
      background:#0f1217; color:var(--text);
      padding:14px 16px; border-radius:14px;
      font-size:16px; font-weight:600; flex:1 1 0;
      transition: transform .08s ease, filter .12s ease, opacity .2s ease, background .2s ease;
      touch-action:manipulation; -webkit-tap-highlight-color:transparent;
    }
    .btn:active{ transform: scale(var(--tapScale)); }

    /* START (green) */
    #btnStart{
      background: var(--accent);
      color:#0a0b0e;
      border-color:#0f6f55;
    }
    #btnStart:hover{ filter:brightness(.95); }

    /* STOP (red) */
    #btnStop{
      background: var(--danger);
      color:#fff;
      border-color:#8b1f19;
    }
    #btnStop:hover{ filter:brightness(.95); }

    .statusLine{
      display:flex; gap:8px; flex-wrap:wrap; color:var(--muted); font-size:14px;
    }
    .statusLine .k{ color:#7f93a8; }
    .statusLine .v{ color:#cfe3ff; }

    /* Overlay (dimmed backdrop + red stop box) */
    .overlay{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding:24px;
      background: rgba(0,0,0,.6);     /* dim only, not full red screen */
      z-index:9999;
      text-align:center;
    }
    .overlay.show{ display:flex; }
    .overlay-box{
      background: var(--danger);
      color:#fff;
      max-width: 340px; width:100%;
      border-radius:16px;
      padding:24px;
      border:3px solid #fff;
      box-shadow: 0 16px 48px rgba(0,0,0,.45);
    }
    .overlay-title{
      font-size:20px; font-weight:800; letter-spacing:.2px; margin:0 0 8px 0;
    }
    .overlay-body{
      font-size:15px; opacity:.95; margin-bottom:14px;
    }
    .overlay-timer{
      display:inline-block; font-variant-numeric:tabular-nums;
      background:#fff; color:#0a0b0e;
      padding:6px 10px; border-radius:999px; font-weight:700;
    }

    footer{
      opacity:.6; font-size:12px; text-align:center; margin-top:6px;
    }

    /* Small helpers */
    .spacer{ flex:1 }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted{ color:var(--muted); }
  </style>
</head>
<body>
  <div class="page">
    <div class="wrap">

      <header class="card">
        <div class="brand">Couples Breath</div>
        <div class="pill mono" id="pillMode">mode: —</div>
      </header>

      <section class="card">
        <div class="statusLine" id="statusLine">
          <div><span class="k">status:</span> <span class="v" id="vStatus">idle</span></div>
          <div><span class="k">mic:</span> <span class="v" id="vMic">off</span></div>
          <div><span class="k">server:</span> <span class="v" id="vServer">—</span></div>
        </div>
      </section>

      <section class="card">
        <div class="row wrap">
          <button id="btnStart" class="btn">Start</button>
          <button id="btnStop" class="btn">Stop</button>
        </div>
      </section>

      <footer>Audio is processed in real time to help you Pause and Breathe.</footer>
    </div>
  </div>

  <!-- Pause + Breathe overlay -->
  <div class="overlay" id="overlay">
    <div class="overlay-box">
      <h2 class="overlay-title">Pause and Breathe</h2>
      <p class="overlay-body">Soft belly, slow exhales. In through the nose… out twice as long.</p>
      <div class="overlay-timer" id="overlayTimer">60s</div>
    </div>
  </div>

  <script>
    // ---------- CONFIG ----------
    // If you pass ?ws=wss://your-proxy/client we’ll use it; otherwise default to your Render URL.
    const qs = new URLSearchParams(location.search);
    const WS_URL = qs.get('ws') || 'wss://pause-proxy.onrender.com/client';

    // WAV writer (kept intentionally identical to your working flow: sends {type:'audio', data_b64})
    const CHUNK_MS = 1000; // ~1s chunks, matches your server logs (~43752 base64 length)
    let mediaStream, audioCtx, processor, micSource, encoder, ws, sendTimer;

    // Simple WAV encoder for mono 16-bit PCM (keeps server happy)
    function pcm16leToWavBase64(float32, sampleRate){
      const numChannels = 1;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataLength = float32.length * bytesPerSample;
      const buffer = new ArrayBuffer(44 + dataLength);
      const view = new DataView(buffer);
      let offset = 0;
      function writeStr(s){ for (let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i)); }
      function write16(v){ view.setUint16(offset, v, true); offset+=2; }
      function write32(v){ view.setUint32(offset, v, true); offset+=4; }

      writeStr('RIFF');           // ChunkID
      write32(36 + dataLength);   // ChunkSize
      writeStr('WAVE');           // Format
      writeStr('fmt ');           // Subchunk1ID
      write32(16);                // Subchunk1Size (PCM)
      write16(1);                 // AudioFormat (PCM)
      write16(numChannels);       // NumChannels
      write32(sampleRate);        // SampleRate
      write32(byteRate);          // ByteRate
      write16(blockAlign);        // BlockAlign
      write16(16);                // BitsPerSample
      writeStr('data');           // Subchunk2ID
      write32(dataLength);        // Subchunk2Size

      // PCM write
      let idx = 44;
      const out = new Int16Array(buffer, 44, float32.length);
      for (let i=0;i<float32.length;i++){
        let s = Math.max(-1, Math.min(1, float32[i]));
        out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }

      // base64
      let binary = '';
      const bytes = new Uint8Array(buffer);
      for (let i=0; i<bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }

    function byId(id){ return document.getElementById(id); }
    const pillMode   = byId('pillMode');
    const vStatus    = byId('vStatus');
    const vMic       = byId('vMic');
    const vServer    = byId('vServer');
    const btnStart   = byId('btnStart');
    const btnStop    = byId('btnStop');
    const overlay    = byId('overlay');
    const overlayTmr = byId('overlayTimer');

    function setStatus(s){ vStatus.textContent = s; }
    function setMic(s){ vMic.textContent = s; }
    function setServer(s){ vServer.textContent = s; }
    function setMode(m){ pillMode.textContent = 'mode: ' + m; }

    function showOverlay(seconds=60){
      overlay.classList.add('show');
      let remain = seconds;
      overlayTmr.textContent = remain + 's';
      const t = setInterval(()=>{
        remain -= 1;
        overlayTmr.textContent = Math.max(remain,0) + 's';
        if (remain <= 0){
          clearInterval(t);
          overlay.classList.remove('show');
        }
      },1000);
      // Also auto-hide if server reconnects with another trigger later — timer handles default.
    }

    // Tap feedback (no pulsing)
    function tapFeedback(el){
      el.style.transform = 'scale(0.98)';
      setTimeout(()=>{ el.style.transform = 'scale(1)'; }, 120);
    }

    // --- WS wiring (kept same message formats) ---
    function connectWS(){
      if (ws && ws.readyState === WebSocket.OPEN) return;
      ws = new WebSocket(WS_URL);
      setServer('connecting');
      ws.onopen = ()=> setServer('connected');
      ws.onerror = ()=> setServer('error');
      ws.onclose = ()=> setServer('closed');
      ws.onmessage = (ev)=>{
        let msg; try{ msg = JSON.parse(ev.data); } catch { return; }
        if (msg.type === 'hello'){
          setMode(msg.mode || 'hume');
        } else if (msg.type === 'hume'){
          setServer(msg.status || '—');
        } else if (msg.type === 'risk'){
          // no on-screen hyper label anymore
        } else if (msg.type === 'trigger'){
          if (msg.kind === 'hyper') {
            showOverlay(60); // 60s exactly
          }
        }
      };
    }

    async function start(){
      tapFeedback(btnStart);
      setStatus('starting…');

      connectWS();

      // mic
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio:true });
      setMic('on');

      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
      micSource = audioCtx.createMediaStreamSource(mediaStream);

      // Use ScriptProcessorNode for wide support
      const BUFFER_SIZE = 4096;
      processor = audioCtx.createScriptProcessor(BUFFER_SIZE, 1, 1);

      const chunk = [];
      let lastSent = performance.now();
      processor.onaudioprocess = (e)=>{
        const input = e.inputBuffer.getChannelData(0);
        // copy into chunk
        const copy = new Float32Array(input.length);
        copy.set(input);
        chunk.push(copy);

        const now = performance.now();
        if (now - lastSent >= CHUNK_MS){
          const total = chunk.reduce((s,a)=>s+a.length,0);
          const joined = new Float32Array(total);
          let o = 0;
          for (const buf of chunk){ joined.set(buf, o); o += buf.length; }
          chunk.length = 0;

          const b64 = pcm16leToWavBase64(joined, audioCtx.sampleRate);
          if (ws && ws.readyState === WebSocket.OPEN){
            try {
              ws.send(JSON.stringify({ type:'audio', data_b64: b64 }));
              // console.log('sent bytesB64=', b64.length);
            } catch {}
          }
          lastSent = now;
        }
      };

      micSource.connect(processor);
      processor.connect(audioCtx.destination); // required in some browsers

      setStatus('listening');
    }

    async function stop(){
      tapFeedback(btnStop);
      setStatus('stopping…');

      try { if (processor) processor.disconnect(); } catch {}
      try { if (micSource) micSource.disconnect(); } catch {}
      try { if (audioCtx) await audioCtx.close(); } catch {}

      try { if (mediaStream) mediaStream.getTracks().forEach(t=>t.stop()); } catch {}
      mediaStream = null; audioCtx = null; processor = null; micSource = null;

      setMic('off');
      setStatus('idle');
    }

    btnStart.addEventListener('click', start);
    btnStop.addEventListener('click', stop);

    // Kick off a WS connection early so we can display mode / server status
    connectWS();
  </script>
</body>
</html>
