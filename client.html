<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Couples Breath</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    :root{
      --bg:#0b0b0c;
      --fg:#ffffff;
      --muted:#9aa0a6;
      --tile:rgba(255,255,255,0.06);
      --tile2:rgba(255,255,255,0.1);
      --accent:#7dd3fc; /* Start button */
      --stop:#f87171;   /* Stop button */
      --shadow:0 10px 30px rgba(0,0,0,0.35);
      --radius:18px;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{
      min-height:100%;
      display:grid;
      grid-template-rows:auto 1fr auto;
      padding:0 16px;  /* stops cutoff on the right */
      box-sizing:border-box;
      gap:16px;
    }
    header{padding:20px 0 6px 0;}
    .title{font-size:22px;font-weight:700;letter-spacing:.2px;}
    .sub{font-size:13px;color:var(--muted);}
    main{display:grid;align-content:start;gap:14px;padding-bottom:10px}
    .card{
      background:var(--tile);
      border:1px solid var(--tile2);
      border-radius:var(--radius);
      padding:14px;
      box-shadow:var(--shadow);
    }
    .row{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      flex-wrap:wrap;
    }
    .pill{
      font-size:12px;color:var(--muted);
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.12);
      padding:6px 10px;border-radius:999px;
    }

    /* Buttons */
    .controls{display:grid;gap:10px;margin:6px 0 24px}
    .btn{
      -webkit-tap-highlight-color:transparent;
      appearance:none;border:none;border-radius:14px;
      padding:16px;width:100%;
      font-size:18px;font-weight:600;color:#0b0b0c;
      box-shadow:var(--shadow);
      transition:transform .08s ease, filter .15s ease, opacity .15s ease;
      cursor:pointer;
    }
    .btn:active{ transform:scale(0.97); filter:brightness(0.9); } /* quick press feedback */
    .btn[disabled]{ opacity:.5; pointer-events:none; }
    .btn.start{ background:var(--accent); }
    .btn.stop { background:var(--stop); }

    /* Overlay: red stop-sign style */
    .overlay{
      position:fixed; inset:0; display:none;
      align-items:center; justify-content:center; z-index:1000;
      backdrop-filter: blur(2px);
      background: rgba(255,0,0,0.25);
      padding:16px; box-sizing:border-box;
    }
    .overlay.show{ display:grid; }
    .stop-panel{
      background:#d32f2f; color:#fff;
      width:min(560px,92vw);
      border-radius:24px;
      border:8px solid rgba(255,255,255,0.85);
      text-align:center;
      padding:40px 20px;
      box-shadow:0 14px 40px rgba(0,0,0,0.45);
    }
    .stop-title{font-size:28px;font-weight:800;letter-spacing:.5px;margin:0 0 6px}
    .stop-sub{font-size:15px;color:#ffecec;margin:0 0 14px}
    .stop-timer{font-variant-numeric:tabular-nums;font-size:48px;font-weight:900;margin:10px 0 0}

    footer{padding-bottom:18px}
    .hint{font-size:12px;color:var(--muted);text-align:center}
    a{color:var(--accent);text-decoration:none}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Couples Breath</div>
      <div class="sub">Tap <strong>Start</strong> and speak normally. If rising arousal is detected, you’ll see “Pause and Breathe.”</div>
    </header>

    <main>
      <div class="card">
        <div class="row">
          <div class="pill" id="status">status: <strong>idle</strong></div>
          <div class="pill" id="mic">mic: <strong>off</strong></div>
          <div class="pill" id="conn">ws: <strong>disconnected</strong></div>
        </div>
      </div>

      <div class="controls">
        <button class="btn start" id="btnStart">Start</button>
        <button class="btn stop"  id="btnStop" disabled>Stop</button>
      </div>

      <div class="card">
        <div class="sub">recent</div>
        <div id="log" style="font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;line-height:1.45;margin-top:8px;white-space:pre-wrap;"></div>
      </div>
    </main>

    <footer>
      <div class="hint">Using proxy at <span id="wsHint"></span></div>
    </footer>
  </div>

  <!-- Red overlay stop panel -->
  <div class="overlay" id="overlay">
    <div class="stop-panel">
      <div class="stop-title">Pause and Breathe</div>
      <p class="stop-sub">Take slow breaths. We’ll continue in a moment.</p>
      <div class="stop-timer" id="stopTimer">60</div>
    </div>
  </div>

  <script>
    // ===== Config: default to your Render proxy; override with ?ws=... if needed
    function pickWS() {
      const p = new URLSearchParams(location.search);
      const u = p.get('ws');
      return u ? u : 'wss://pause-proxy.onrender.com/client';
    }
    const WS_URL = pickWS();
    document.getElementById('wsHint').textContent = WS_URL;

    // ===== UI helpers
    const elStatus = document.getElementById('status');
    const elMic    = document.getElementById('mic');
    const elConn   = document.getElementById('conn');
    const elLog    = document.getElementById('log');
    const overlay  = document.getElementById('overlay');
    const stopTimerEl = document.getElementById('stopTimer');
    const btnStart = document.getElementById('btnStart');
    const btnStop  = document.getElementById('btnStop');

    function setPill(el, txt){ el.innerHTML = txt; }
    function log(s){
      const ts = new Date().toLocaleTimeString();
      elLog.textContent = `[${ts}] ${s}\n` + elLog.textContent;
      const lines = elLog.textContent.split('\\n');
      if (lines.length > 200) elLog.textContent = lines.slice(0,200).join('\\n');
    }

    // ===== WS & audio state
    let ws = null;
    let mediaStream = null;
    let mediaRec = null;

    // ===== Overlay countdown (60s)
    let countdownTimer = null;
    function showPauseOverlay(seconds=60){
      try{ clearInterval(countdownTimer); }catch{}
      overlay.classList.add('show');
      let remain = seconds;
      stopTimerEl.textContent = remain;
      countdownTimer = setInterval(()=>{
        remain -= 1;
        if (remain <= 0) {
          hidePauseOverlay();
        } else {
          stopTimerEl.textContent = remain;
        }
      }, 1000);
    }
    function hidePauseOverlay(){
      overlay.classList.remove('show');
      try{ clearInterval(countdownTimer); }catch{}
    }

    // ===== Base64 helper
    function base64FromArrayBuffer(ab){
      const bytes = new Uint8Array(ab);
      let bin = '';
      const chunk = 0x8000; // 32k chunks to avoid call stack limits
      for (let i = 0; i < bytes.length; i += chunk) {
        bin += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
      }
      return btoa(bin);
    }

    // ===== Audio capture (MediaRecorder, send base64 to proxy)
    async function startAudio(){
      if (mediaRec) return;
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      setPill(elMic, 'mic: <strong>on</strong>');
      const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
        ? 'audio/webm;codecs=opus'
        : 'audio/webm';
      mediaRec = new MediaRecorder(mediaStream, { mimeType: mime });

      mediaRec.addEventListener('dataavailable', async (e) => {
        if (!e.data || e.data.size === 0 || !ws || ws.readyState !== 1) return;
        try {
          const buf = await e.data.arrayBuffer();
          const b64 = base64FromArrayBuffer(buf);
          ws.send(JSON.stringify({ type: 'audio', data_b64: b64 }));
          log('sent wav bytes (base64 len = ' + b64.length + ')');
        } catch (err) {
          log('send error: ' + (err?.message || err));
        }
      });

      // push a chunk every second
      mediaRec.start(1000);
    }

    function stopAudio(){
      try { mediaRec?.stop(); } catch {}
      try { mediaStream?.getTracks().forEach(t=>t.stop()); } catch {}
      mediaRec = null;
      mediaStream = null;
      setPill(elMic, 'mic: <strong>off</strong>');
    }

    // ===== WS connect/disconnect
    function connectWS(){
      if (ws && (ws.readyState === 0 || ws.readyState === 1)) return;
      ws = new WebSocket(WS_URL);
      setPill(elConn, 'ws: <strong>connecting...</strong>');

      ws.addEventListener('open', () => {
        setPill(elConn, 'ws: <strong>connected</strong>');
        setPill(elStatus, 'status: <strong>listening</strong>');
        log('ws open');
      });

      ws.addEventListener('message', (ev) => {
        let msg = null;
        try { msg = JSON.parse(ev.data); } catch {}
        if (!msg) return;

        if (msg.type === 'hello') {
          log('proxy hello (mode: ' + msg.mode + ')');
        } else if (msg.type === 'hume') {
          if (msg.status === 'connected') log('hume connected');
          if (msg.status === 'closed')    log('hume closed');
          if (msg.status === 'error')     log('hume error: ' + (msg.message||''));
        } else if (msg.type === 'risk') {
          // we removed the hyper readout from UI; just log
          log('risk update');
        } else if (msg.type === 'trigger') {
          if (msg.kind === 'hyper') {
            log('TRIGGER: hyper (' + (msg.score?.toFixed?.(2) ?? '') + ')');
            showPauseOverlay(60);
          }
        } else if (msg.type === 'ack') {
          // optional ack from proxy in mock mode
          log('ack: ' + (msg.received || ''));
        }
      });

      ws.addEventListener('close', (ev) => {
        setPill(elConn, 'ws: <strong>disconnected</strong>');
        setPill(elStatus, 'status: <strong>idle</strong>');
        log('ws closed ' + (ev.code || ''));
      });

      ws.addEventListener('error', (e) => {
        setPill(elConn, 'ws: <strong>error</strong>');
        log('ws error: ' + (e?.message || ''));
      });
    }

    function disconnectWS(){
      try { ws?.close(); } catch {}
      ws = null;
      setPill(elConn, 'ws: <strong>disconnected</strong>');
      setPill(elStatus, 'status: <strong>idle</strong>');
    }

    // ===== Button wiring
    btnStart.addEventListener('click', async () => {
      btnStart.disabled = true;
      try {
        connectWS();
        await startAudio();
      } catch (e) {
        log('start failed: ' + (e?.message || e));
        btnStart.disabled = false;
        return;
      }
      btnStop.disabled = false;
    });

    btnStop.addEventListener('click', () => {
      btnStop.disabled = true;
      hidePauseOverlay();
      stopAudio();
      disconnectWS();
      btnStart.disabled = false;
    });

    // iOS: request mic on first gesture only (button click above). Nothing else to do here.
  </script>
</body>
</html>
