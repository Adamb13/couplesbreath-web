<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Couples Breath</title>
  <style>
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial; margin: 0; background:#0b1020; color:#e6eefc; }
    .wrap { display:flex; min-height:100vh; align-items:center; justify-content:center; padding:24px; }
    .card { width:100%; max-width:520px; background:#121a33; border:1px solid #223055; border-radius:20px; padding:20px; box-shadow: 0 6px 24px rgba(0,0,0,0.25); }
    h1 { margin: 0 0 8px; font-size: 24px; letter-spacing: 0.3px; }
    .muted { color:#9fb2d9; font-size: 14px; margin-bottom: 16px; }
    .row { display:flex; gap:8px; align-items:center; margin:12px 0; flex-wrap:wrap; }
    .btn { appearance:none; border:0; border-radius:12px; padding:12px 16px; background:#3b82f6; color:white; font-weight:600; font-size:16px; }
    .btn.stop { background:#ef4444; }
    .state { font-variant-numeric: tabular-nums; background:#0e1530; border:1px solid #1e2a4c; border-radius:12px; padding:10px 12px; }
    .overlay {
      position: fixed; inset: 0;
      display: none; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.75); z-index: 9999;
    }
    .overlay.show { display:flex; }
    .bubble {
      background: #fef3c7; color:#111827;
      border-radius: 20px;
      padding: 22px 20px;
      width: min(92vw, 520px);
      text-align:center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.35);
    }
    .bubble h2 { margin: 0 0 6px; font-size: 22px; }
    .bubble p { margin: 6px 0 0; font-size: 16px; line-height:1.35; color:#1f2937; }
  </style>
</head>
<body>
  <div class="overlay" id="pauseOverlay" aria-hidden="true">
    <div class="bubble">
      <h2>Time to pause</h2>
      <p>Let’s take three slow breaths. In through the nose, out through the mouth.</p>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <h1>Couples Breath</h1>
      <div class="muted">Early-warning helper during tough conversations.</div>

      <div class="row">
        <button id="startBtn" class="btn">Start session</button>
        <button id="stopBtn" class="btn stop" disabled>Stop</button>
      </div>

      <div class="row">
        <div class="state">
          <div id="mode">mode: –</div>
          <div id="status">status: idle</div>
          <div id="risk">hyper: –</div>
        </div>
      </div>

      <div class="muted" style="margin-top:8px">
        • Keep the phone between you on a table.  
        • Speak as you normally would.
      </div>
    </div>
  </div>

  <script>
    // Bump this string when you change the file, then reload with ?v= to beat iOS cache.
    const VERSION = '2025-08-16-a';

    const PROXY_WS = 'wss://pause-proxy.onrender.com/client'; // your Render proxy

    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const modeEl   = document.getElementById('mode');
    const statusEl = document.getElementById('status');
    const riskEl   = document.getElementById('risk');
    const overlay  = document.getElementById('pauseOverlay');

    let ws = null;
    let mediaRec = null;
    let stream = null;

    function showOverlay(on) {
      overlay.classList.toggle('show', !!on);
      overlay.setAttribute('aria-hidden', on ? 'false' : 'true');
    }

    function speak(text) {
      try {
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 0.95;
        u.pitch = 1.0;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      } catch {}
    }

    async function startSession() {
      statusEl.textContent = 'status: requesting mic…';

      try {
        // Ask for mic (iOS Safari requires user gesture: the Start button is one)
        stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      } catch (e) {
        statusEl.textContent = 'status: mic denied';
        alert('Microphone permission is needed to monitor the discussion.');
        return;
      }

      // Open WS to proxy
      ws = new WebSocket(PROXY_WS);
      ws.onopen = () => {
        statusEl.textContent = 'status: connected';
      };
      ws.onmessage = (evt) => {
        let msg; try { msg = JSON.parse(evt.data); } catch { return; }

        if (msg.type === 'hello') {
          modeEl.textContent = 'mode: ' + msg.mode;
        } else if (msg.type === 'risk' && typeof msg.hyper === 'number') {
          riskEl.textContent = 'hyper: ' + msg.hyper.toFixed(2);
        } else if (msg.type === 'trigger') {
          showOverlay(true);
          speak('Time to pause. Let’s take three slow breaths together.');
          // Auto-hide after ~12s so the couple can continue
          setTimeout(() => showOverlay(false), 12000);
        } else if (msg.type === 'hume' && msg.status === 'error') {
          statusEl.textContent = 'status: error';
        }
      };
      ws.onclose = () => { statusEl.textContent = 'status: closed'; };

      // Start recording in small chunks; Hume accepts these as media blobs.
      const mime = MediaRecorder.isTypeSupported('audio/webm; codecs=opus')
        ? 'audio/webm; codecs=opus' : 'audio/webm';

      mediaRec = new MediaRecorder(stream, { mimeType: mime, audioBitsPerSecond: 32000 });
      mediaRec.ondataavailable = async (e) => {
        if (!e.data || !e.data.size || !ws || ws.readyState !== 1) return;
        try {
          const b64 = await blobToBase64(e.data);
          ws.send(JSON.stringify({ type: 'audio', data_b64: b64 }));
        } catch {}
      };
      // timeslice: emit a chunk every 800–1000ms
      mediaRec.start(900);

      startBtn.disabled = true;
      stopBtn.disabled = false;
      showOverlay(false);
    }

    function stopSession() {
      try { mediaRec && mediaRec.state !== 'inactive' && mediaRec.stop(); } catch {}
      try { stream && stream.getTracks().forEach(t => t.stop()); } catch {}
      try { ws && ws.readyState === 1 && ws.close(); } catch {}
      mediaRec = null; stream = null; ws = null;

      startBtn.disabled = false;
      stopBtn.disabled = true;
      statusEl.textContent = 'status: idle';
      // We leave the last risk value visible for context
    }

    function blobToBase64(blob) {
      return new Promise((res, rej) => {
        const fr = new FileReader();
        fr.onerror = () => rej(new Error('read failed'));
        fr.onload = () => {
          const dataUrl = fr.result; // "data:audio/webm;codecs=opus;base64,AAAA..."
          const b64 = String(dataUrl).split(',')[1] || '';
          res(b64);
        };
        fr.readAsDataURL(blob);
      });
    }

    startBtn.addEventListener('click', startSession);
    stopBtn.addEventListener('click', stopSession);

    console.log('Couples Breath client', VERSION);
  </script>
</body>
</html>
